#!/bin/bash

# This script provides the main interface for interacting with the command line utilities used for
# starting and configuring the Live Lightshow.
#
# Arguments:
# <subcommand> possible values: *see below*
#
# Return status:
# 1: <subcommand> was invalid
# otherwise: $? of the given subcommand


#-Preliminaries---------------------------------#


# This will be overwritten upon installation.
# APP-DIRECTORY
readonly app_directory="$(realpath "$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)")/.."

# Imports.
. "$app_directory/Utilities/lookup.sh"


#-Functions-------------------------------------#


# Returns on success if the light show's running-status matched a given flag, or else prints an
# error message and returns on failure.
#
# Arguments:
# * <run status flag> possible values: "--running", "--not-running"
#
# Return status:
# 0: success
# 1: the given flag was invalid
# 2: the running-status of the light show does not match the given flag
function assert_lightshow_ {
   case "$1" in
      --running)
         if [ -z "$("$app_directory/Command Line Interface/live_pids.sh")" ]; then
            echo -e "${print_red}No light show is currently running.$print_normal"
            return 2
         fi ;;
      --not-running)
         if [ -n "$("$app_directory/Command Line Interface/live_pids.sh")" ]; then
            echo -e "${print_red}A light show is currently running.$print_normal"
            return 2
         fi ;;
      *)
         print_error_for --flag "$1"; return 1 ;;
   esac

   return 0
}

# Ends a light show if one is running, or prints an error and returns on failure if none is running.
#
# Return status:
# 0: success
# 1: no light show is currently running
function end_lightshow_ {
   assert_lightshow_ --running || return 1

   local -r pids=$("$app_directory/Command Line Interface/live_pids.sh")
   while read pid; do silently- kill "$pid"; done <<< "$pids"

   echo -e "${print_green}Lightshow ended.$print_normal"
}

# This function handels the `live` subcommand.
#
# Arguments:
# * <main's $2, $3, ...>
#
# Returns:
# 1: <$2> was an invalid subcommand
# otherwise: $? of the given subcommand
function subcommand_live_ {
   # Binds the subcommand to `live` and realigns the arguments.
   local -r live_subcommand="$1"
   shift

   case "$live_subcommand" in
      status)
         assert_lightshow_ --running || return 1
         "$app_directory/Command Line Interface/live_status.sh" ;;

      configure)
         assert_lightshow_ --running || return 1
         "$app_directory/Catalogue/Scripts/Runtime/configure_server_instance.sh" "$@"
         readonly return_status=$?
         if [ $return_status -eq 1 ]; then
            echo -e "${print_red}This command expects a server-instance as argument.$print_normal"
            return 1
         elif [ $return_status -eq 2 ]; then
            echo -e "${print_red}The given server-instance is not currently defined.$print_normal"
            return 2
         fi ;;

      *)
         echo -e "$(text_for_ subcommand-live-usage)"
         return 1 ;;
   esac
}


#-Main------------------------------------------#


# Binds the subcommand and shifts the rest of the command line arguments to be passable to the
# subcommand.
readonly subcommand=$1
shift

# Runs the script corresponding to the given subcommand, or prints an error message and returns on
# failure if the given subcommand was invalid.
case "$subcommand" in
   initialize)
      assert_lightshow_ --not-running || exit 1
      "$app_directory/Command Line Interface/push_program.sh" || exit $?
      "$app_directory/Catalogue/Scripts/Static/reindex_static.sh" ;;
   start)
      assert_lightshow_ --not-running || exit 1
      "$app_directory/Command Line Interface/start_lightshow.sh"

      # start <rack name: optional>

      ;;
   live)
      subcommand_live_ "$@" || exit $?

      # save <new rack name>

      ;;
   end)
      end_lightshow_ || exit 1 ;;
   directory)
      echo "$(realpath "$app_directory")" ;;
   reindex)
      assert_lightshow_ --not-running || exit 1
      "$app_directory/Catalogue/Scripts/Static/reindex_static.sh" ;;
   *)
      echo -e "$(text_for_ lightshow-usage)"
      exit 1 ;;

   server)
      # import <file-path> <custom-server name: optional>
      # > Make sure none of the server classes match class names from the Lightshow-directory or
      # > server names of existing servers.

      # remove <server name>
      # > Notify about racks affected by this removal.

      # info <server name>
      # > Print the static configuration of the server, or possibly add #info-begin, #info-end tags
      # > for servers to display a custom explaination.
      ;;
   rack)
      # list
      # > like _lightshow status_ but for racks

      # configure <rack name>

      # make <new rack's name>

      # remove <rack name>
      ;;
esac

exit 0
